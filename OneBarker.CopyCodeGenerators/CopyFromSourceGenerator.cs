using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace OneBarker.CopyCodeGenerators
{
    [Generator]
    public class CopyFromSourceGenerator : IIncrementalGenerator
    {
        private const string Namespace     = "Generators";
        private const string AttributeName = "EnableCopyFromAttribute";

        private const string AttributeSourceCode = @"// <auto-generated/>

using System;

namespace " + Namespace + @"
{
    /// <summary>
    /// Generates a CopyFrom method taking the provided TypeToCopy as an argument. 
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct, AllowMultiple = true)]
    internal class " + AttributeName + @" : Attribute
    {
        public Type TypeToCopy { get; }
        
        public " + AttributeName + @"(Type typeToCopy)
        {
            TypeToCopy = typeToCopy;
        }
    }
}";

        private const string FullAttributeName = Namespace + "." + AttributeName;

        private readonly CopyCodeGenerator _generator = new CopyCodeGenerator(
            (target, source, param, set)
                => $"public new {target} CopyFrom({source} {param})",
            (target, source, set)
                => "Copies properties from the source object to this object and returns this object.",
            "CopyFrom",
            CopyCodeGenerator.MethodReturnType.This,
            addBeforeMethod: true,
            addAfterMethod: true
        );

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Add the marker attribute to the compilation.
            context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
                    $"{AttributeName}.g.cs",
                    SourceText.From(AttributeSourceCode, Encoding.UTF8)
                )
            );

            // Filter classes annotated with the attribute. Only filtered Syntax Nodes can trigger code generation.
            var provider = context.SyntaxProvider
                                  .CreateSyntaxProvider(
                                      (s,   _) => s is ClassDeclarationSyntax || s is StructDeclarationSyntax,
                                      (ctx, _) => ctx.GetCopyClassDeclarationSetForSourceGen(FullAttributeName)
                                  )
                                  .Where(t => t.AttributeFound)
                                  .Select((t, _) => t);

            // Generate the source code.
            context.RegisterSourceOutput(
                context.CompilationProvider.Combine(provider.Collect()),
                (ctx, t) => _generator.Generate(ctx, t.Left, t.Right)
            );
        }
    }
}
