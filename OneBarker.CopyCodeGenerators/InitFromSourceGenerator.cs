using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace OneBarker.CopyCodeGenerators
{
    [Generator]
    public class InitFromSourceGenerator : IIncrementalGenerator
    {
        private const string Namespace     = "Generators";
        private const string AttributeName = "EnableInitFromAttribute";

        private const string AttributeSourceCode = @"// <auto-generated/>

using System;

namespace " + Namespace + @"
{
    /// <summary>
    /// Generates a constructor method taking the provided TypeToCopy as an argument. 
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct, AllowMultiple = true)]
    internal class " + AttributeName + @" : Attribute
    {
        public Type TypeToCopy { get; }
        
        public " + AttributeName + @"(Type typeToCopy)
        {
            TypeToCopy = typeToCopy;
        }
    }
}";

        private const string FullAttributeName = Namespace + "." + AttributeName;

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Add the marker attribute to the compilation.
            context.RegisterPostInitializationOutput(
                ctx => ctx.AddSource(
                    $"{AttributeName}.g.cs",
                    SourceText.From(AttributeSourceCode, Encoding.UTF8)
                )
            );

            // Filter classes annotated with the attribute. Only filtered Syntax Nodes can trigger code generation.
            var provider = context.SyntaxProvider
                                  .CreateSyntaxProvider(
                                      (s,   _) => s is ClassDeclarationSyntax || s is RecordDeclarationSyntax || s is StructDeclarationSyntax,
                                      (ctx, _) => ctx.GetCopyClassDeclarationSetForSourceGen(FullAttributeName)
                                  )
                                  .Where(t => t.AttributeFound)
                                  .Select((t, _) => t);

            // Generate the source code.
            context.RegisterSourceOutput(
                context.CompilationProvider.Combine(provider.Collect()),
                (ctx, t) => ctx.GenerateCopyCode(
                    t.Left,
                    t.Right,
                    GenerateDeclaration,
                    (target, source) => $"Creates an instance of {target} with values from the provided object.",
                    "Construct",
                    false,
                    false,
                    false,
                    true
                )
            );
        }

        private string GenerateDeclaration(
            string                  targetClass,
            string                  sourceClass,
            string                  paramName,
            CopyClassDeclarationSet set
        )
        {
            var haveDefaultConstructor = set
                                         .TargetClass
                                         .ChildNodes()
                                         .OfType<ConstructorDeclarationSyntax>()
                                         .Any(x => x.ParameterList.Parameters.Count == 0);
            
            
            // default to the parameterless constructor if defined.
            var callDefault                                             = haveDefaultConstructor ? " : this()" : "";
            
            // record copy constructors cannot call "this()".
            if (set.TargetClass is RecordDeclarationSyntax && string.Equals(targetClass, sourceClass)) callDefault = "";
            
            // records with parameterized constructors must have the primary constructor called.
            var recParamList =
                ((set.TargetClass as RecordDeclarationSyntax)?.ParameterList?.Parameters)
                .GetValueOrDefault()
                .ToArray();

            // do not use the passthrough methods when creating a copy constructor.
            if (recParamList.Length > 0 && !string.Equals(sourceClass, targetClass))
            {
                callDefault = " : this(" 
                              + string.Join(
                                  ", ",
                                  recParamList
                                      .Select(x => x.Identifier.Text)
                                      .Select(x => $"PassthroughTransform_{x}({paramName})")
                                  ) 
                              + ")";
            }
            
            return $"public {targetClass}({sourceClass} {paramName}){callDefault}";
        }
        
    }
}
